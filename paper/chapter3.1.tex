
\chapter{Vergleich grundlegender Konzepte}

\section{Spezifikationen und Prädikate für equal}
\label{sec:design-by-contract}
\subsection{Design by Contract}

Bei der formalen Verifikation geht es darum sicherzustellen, dass ein entsprechendes Stück Software
funktional korrekt ist. Das wird erreicht, in dem man die Bausteine der Sprache - in C sind es zum Beispiel die Methoden 
oder Strukturen -
Stück für Stück formalisiert und verifiziert. Die Signatur einer Methode stellt bereits einen einfachen Vertrag zwischen
Aufrufenden und Aufrufer dar - Parameteranzahl und ihre Typen sind festgelegt, genauso wie der Rückgabewert.
Um auch die funktionalen Aspekte der Methode zu beschreiben, wird diese Vereinbarung um sogenannte Vor- und Nachbedingungen erweitert.
Diese beschreiben das Resultat der Methode sowie notwendige Annahmen, die vor dem Aufrufen der Methode gegeben sein müssen. 

Somit entstehen exakte vollständig formalisierte Bausteine, die keinen Raum für Ungenauigkeiten oder Interpretationen zulassen.
Diese Herangehensweise nennt sich Design by Contract und ist die Grundidee der meisten Verifikationswerkzeuge.



\subsection{ACSL-Spezifikation für equal}
\label{sec:design-by-contract:acsl-spezifikation}

Nachfolgend ist ein einfaches Beispiel einer ACSL-Funktions-Spezifikation dargestellt.
Die Funktion equal prüft zwei Ganzzahlen-Arrays auf Gleichheit:

\lstinputlisting[language=C]{codes/equal_contract_acsl.c}

Der spezielle @-Präfix in Zeile 1 signalisiert dem Verifikationswerkzeug, 
dass der folgende Kommentarblock als Verifikations-Annotation zu interpretieren ist. Normale C-Compiler hingegen
ignorieren den Kommentar.

Die Vorbedingungen sind in Zeile 2 und 3 zu finden: \lstinline{IsValidRange} ist ein Prädikat, welches hier sicherstellt,
dass die Zeiger \lstinline{a} und \lstinline{b} gültig sind und auf den Speicherbereich \lstinline{a[0..n]} 
(von \lstinline{a[0]} bis \lstinline{a[n-1]}) bzw. \lstinline{b[0..n]} zugegriffen 
werden darf. Zusätzlich verbietet das Prädikat negative Array-Größen.

Die \lstinline{\assigns}-Klausel beschreibt potenzielle Seiteneffekte. Da es sich bei equal um eine nicht mutierende
Funktion handelt, wird kein Speicherinhalt (\lstinline{\nothing}) verändert.

Der Rückgabewert, identifiziert durch \lstinline{\result}, wird durch die Nachbedingung in Zeile 7 definiert. Er ist genau dann
wahr, wenn die Ganzzahlen-Arrays \lstinline{a[0..n]} und \lstinline{b[0..n]} elementweise gleich sind. Ansonsten ist der 
zurückgegebene Bool-Wert falsch. 

Erreicht wird dies mit Hilfe des Prädikats \lstinline{IsEqual}. Dieses wiederum
nutzt folgende Aussage in Prädikatenlogik (erster Stufe mit Identifikation), um zu definieren wann genau 
zwei Arrays \lstinline{a} und \lstinline{b} der Länge \lstinline{n} gleich sind:
\[IsEqual(a, n, b) \equiv \forall(i) (0 \leq i < n \rightarrow a[i] = b[i])\]

Weitere Details zur allgemeinen Funktionsweise als auch speziell zu diesen Prädikaten siehe
\ref{sec:design-by-contract:predicates}.



\subsection{Vergleich mit Verifast-Spezifikation}
\label{sec:design-by-contract:verifast-variante}

Als Vergleich nun eine semantisch identische Spezifikation in Verifast:

\lstinputlisting[language=C]{codes/equal_contract_verifast.c}

Als erstes fällt die unterschiedliche Platzierung der Annotation auf: In Verifast werden die 
Annotations-Kommentare nach der Signatur augeführt und nicht davor. Außerdem müssen alle Vor- und 
Nachbedingungen in nur einer einzigen \lstinline{requires} bzw. \lstinline{ensures}-Anweisung 
zusammengefasst werden.

Eine \lstinline{assigns}-Klausel taucht auch nicht auf. Dennoch ist erkennbar, dass es sich um einen 
nicht-mutierenden Algorithmus handelt. Anders als in ACSL wird nicht explizit angegeben ob und auf welche 
Speicherstellen zugegriffen werden darf. Stattdessen wird eine Aussage über den Speicherinhalt selbst 
getroffen. Der \lstinline{x |-> y} Operator (engl. points-to) spielt dabei eine wichtige Rolle. Er gibt an, 
dass die Speicherstelle \lstinline{x} den Inhalt \lstinline{y} hat. Gleichzeitig stellt Verifast sicher, 
dass der Zeiger \lstinline{x} gültig ist - analog zur \lstinline{\valid(x)} Anweisung aus ACSL.

Unbekannte Werte werden per Mustererkennung (engl. pattern matching) ergänzt. Die Klausel
\lstinline{a[0..n] |-> ?al} hat damit zwei Aufgaben: Sicherstellen, dass die Zeiger \lstinline{a[0..n]}
gültig sind; sowie den dahinterliegenden Speicherinhalt identifizieren und an die Variable \lstinline{al}
binden. Verifast erlaubt die Verwendung dieser Variablen sogar in den Nachbedingungen. Damit hat man ein 
adäquates Mittel, um alte Werte (aus der Zeit des Methodenaufrufes) zu verwenden, um Seiteneffekte zu
beschreiben sowie Speicherinhalte zu vergleichen. In ACSL wäre für eine ähnliche Herangehensweise
die Verwendung von \lstinline{\old} notwendig.

Aussagen über den Speicherinhalt werden in Verifast mit der speziellen Konjunktion \lstinline{&*&} 
verbunden. In diesem Beispiel wird hier z.B. die Vorbedingung \lstinline{n >= 0} mit Aussagen zu den 
Speicherbereichen \lstinline{a[0..n]} und \lstinline{b[0..n]} verknüpft. Der \lstinline{&&} Operator 
existiert zusätzlich für logische Verknüpfungen.

Die Klauseln \lstinline{a[0..n] |-> al} und \lstinline{b[0..n] |-> bl} in Zeile 3 stellen nun also sicher, 
dass der Speicherinhalt unverändert bleibt. Der Rückgabewert wird in Verifast mit \lstinline{result} 
(ohne vorangestellten Backslash wie in ACSL) bezeichnet. Der Ausdruck \lstinline{result == (al == bl)} 
bewirkt, dass der von der Funktion zurückgegebene Wert genau dann wahr ist, wenn die Inhalte der 
Speicherbereiche \lstinline{al} und \lstinline{bl} gleich sind.

\todo{das nochmal mit acsl testen}
Ein wichtiger semantischer Unterschied zur \lstinline{\assigns nothing}-Klausel besteht noch darin, 
dass ACSL jede Manipulation des Speichers (außer im aktuellen Aufrufrahmen des Stacks) verbietet. 
Verifast jedoch garantiert nur, dass der Inhalt des Speichers nach dem Aufruf gleich ist. Damit wäre 
das Verändern und anschließende Zurück-verändern erlaubt - eine Feinheit, die im Kontext der
Parallelprogrammierung wichtig ist.

Verifast hat eigens für diesen Zweck sogenannte Fractional Permissions, mit denen sich Gleiches
erreichen lässt. Darauf wird in dieser Arbeit aber nicht weiter eingegangen.

Die Verifast-Spezifikation hat also tatsächlich (fast) die gleiche Semantik, erreicht dies aber wegen der 
zu Grunde liegenden Seperation Logic (siehe \ref{sec:theorie:seperation-logic}) auf eine andere ganz 
andere Art und Weise.

\subsection{Einfache und rekursive Prädikate}
\label{sec:design-by-contract:predicates}

Prädikate sind ein grundlegendes Abstraktionsmittel zum Zusammenfassen und Wiederverwenden von logischen 
Formeln in ACSL und Verifast.

Weiter oben wurde das Prädikat \lstinline{IsEqual} definiert, hier sei nun exemplarisch die ACSL-Notation
für diese Aussage dargestellt:

\lstinputlisting[language=C]{codes/equal_predicate_acsl.c}

Die Annotation ist eine direkte Umsetzung der Formel von oben - die Interpretation ist klar verständlich für 
jeden, der prädikatenlogische Formeln lesen kann.

\todo{in acsl gibt es induktive prädikate, die ähnliches erlauben}
In Verifast sind neben solch einfachen Prädikaten auch rekursive möglich. Damit ergibt sich die Möglichkeit
unbegrenzte Datenstrukturen zu beschreiben \todo{referenz auf verifast-tutorial seite 9, chapter 7}. In dieser
Arbeit sind allerdings nur Arrays mit bekannter Länge Untersuchungsgegenstand. Doch auch für diese sind
rekursive Prädikate in Verifast die natürliche Art der Beschreibung. Beispielsweise können Ganzzahl-Arrays
wie folgt definiert werden:

\lstinputlisting[language=C]{codes/int_array_verifast.c}
 
Das Prädikat verweist solange auf sich selbst bis \lstinline{count <= 0}. Dass jede Speicherstelle tatsächlich
gültig ist, stellt das in Verifast eingebaute Prädikat \lstinline{integer} sicher. In dieser Form ist das Prädikat
\lstinline{int_array} nun praktisch identisch mit der \lstinline{IsValidRange}-Variante aus der ACSL-Spezifikation, 
die in \ref{sec:design-by-contract:acsl-spezifikation} zu sehen war.

Auffällig ist an der Stelle noch die Verwendung des \lstinline{_}-Zeichens in Zeile 3. Wie in vielen anderen 
Sprachen auch bezeichnet es eine anonyme Variable, die an dieser Stelle zwar angegeben werden muss, aber deren 
Inhalt nicht weiter interessiert. 

Wird das \lstinline{integer} Prädikat ohne anonyme Variable verwendet, bedeutet der Aufruf von 
\lstinline{integer(start, ?s)} so viel wie \lstinline{*start |-> ?s}. Allerdings erlaubt Verifast
den Einsatz des \lstinline{|->} Operators nicht zusammen mit der Derefenzierung eines einzelnen
Ganzzahl-Wertes.

Tatsächlich ist der Einsatz des \lstinline{int_array(a, n)} Prädikats äquivalent mit der Schreibweise 
von \lstinline{a[0..n] |-> _}, denn Verifast behandelt die Array-Notation intern wie ein rekursives
Prädikat.

Die vollständige Fassung dieses Prädikats wird weiter unten in \ref{sec:induktive-listen} beschrieben.



\subsection{Unvollständige Spezifikationen: Robustheit als Ziel}
\label{sec:design-by-contract:partielle-korrektheit}

Das Ziel der in \ref{sec:design-by-contract:acsl-spezifikation} vorgestellten Spezifikation war die
vollständige funktionale Definition, damit kein Raum für Interpretationen frei bleibt. Allerdings ist
das nicht immer gewünscht: Soll die Robustheit der Software sichergestellt werden, so ist das Aufspüren 
von potenziellen Null-Zeiger-Ausnahmen oder Speicherlöchern das Ziel und nicht die funktionale
Korrektheit. Für ersteres reicht eine reduzierte Spezifikation - funktionale Aspekte werden dabei 
weggelassen oder ggf. vereinfacht:

\lstinputlisting[language=C]{codes/equal_partial_contract_verifast.c}
 
Diese Spezifikation ge ist immer noch korrekt für eine equal-Implementierung, stellt aber selber nur sicher,
dass die Zeiger gültig sind und auf den Speicherbereich zugegriffen werden darf. Der Rückgabewert sowie 
der nicht mutierender Charakter des Algorithmus ist nun nicht mehr formalisiert.

Denkbar ist auch die Verifizierung der gültigen Aufrufreihenfolge (einer gedachten Zustandsmaschine),
ohne alle weiteren Nachbedingungen und Ergebnisse zu formalisieren. Somit kann sichergestellt werden,
dass sich die Zustandsmaschine niemals in einem ungültigen Zustand befindet. Ansonsten erforderliche
Laufzeit-Überprüfungen können wegfallen.



\subsection{Lesbarkeit von Spezifikationen}
\label{sec:design-by-contract:behaviors}

In ACSL gibt es die Möglichkeit mehrere (meist disjunkte) Fälle innerhalb einer Spezifikation getrennt
aufzuschreiben. Das erleichtert die Lesbarkeit erheblich, da man für jeden Fall die Vor- und Nachbedingungen
einzeln lesen kann.

Folgende Spezifikation von equal ist eine Variante in ACSL ohne \lstinline{IsEqual}-Prädikat:

\lstinputlisting[language=C]{codes/equal_behavior_acsl.c}

Der Fall \lstinline{all_equal} in Zeile 7 tritt dann ein, wenn beide Ganzzahl-Arrays gleich sind. Das 
Gegenteil \lstinline{some_not_equal} ist in Zeile 11 definiert, die jeweiligen Bedingungen in Form von
prädikatenlogischen Formeln finden sich als \lstinline{assumes}-Anweisungen wieder. Besonders anzumerken ist,
dass die Anweisungen \lstinline{complete behaviors} bzw. \lstinline{disjoint behaviors} dafür sorgen, dass
alle Fälle abgedeckt sowie disjunkt sind.

In Verifast ist das nur manuell zu erreichen, allerdings mit vergleichsweise längeren Ausdrücken. Reicht 
es in ACSL die \lstinline{assumes}-Fälle \lstinline{a, b, c} als \lstinline{behavior} 
aufzulisten und per \lstinline{disjoint behaviors} zu verknüpfen, so muss in Verifast die folgende
Formel geschrieben werden:
\[(a \land \neg b \land \neg c) \lor (\neg a \land b \land \neg c) \lor (\neg a \land \neg b \land c)\]

Die wichtigsten Abstraktionsmittel sind jedoch in Verifast als auch ACSL die Prädikate. 
Für die \lstinline{equal}-Spezifikation ist z.B. bei Verwendung des \lstinline{IsEqual}-Prädikats gar kein Behavior mehr notwendig,
siehe \ref{sec:design-by-contract:acsl-spezifikation}. Solch eine Spezifikation ist besser 
verständlich, nicht nur weil sie kürzer ist, auch weil die Prädikatenformel verschwunden ist. 
Damit kann sie nun mindestens oberflächlich auch dann verstanden werden, wenn kein 
prädikatenlogisches Wissen vorhanden ist.

Die Definition der möglichen Seiteneffekte ist in den Sprachen unterschiedlich gelöst. In ACSL
ist an Hand der \lstinline{assigns \nothing} Klausel sofort ersichtlich, dass keine Speichermanipulation
erfolgt. Dieser Aspekt ist in Verifast nicht so schnell zu erfassen.

