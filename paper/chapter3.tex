\chapter{Vergleich der Sprachen für die Funktionskontrakte}
\label{sec:design-by-contract}

Dieses Kapitel vergleicht die Sprachkonstrukte aus ACSL und Verifast für die Beschreibung von Funktionskontrakten.

Nutzerdefinierte Prädikate und induktive Listen werden an Hand des einfachen \texttt{equal}-Algorithmus vorgestellt.
Daraufhin wird eine weitere Strukturierungsmöglichkeit für Kontrakte in ACSL diskutiert und bei der anschließenden
Formalisierung von \texttt{mismatch} verwendet. Die Verifast-Variante wird vorgestellt und auf die Unterschiede
der beiden Umsetzungen eingegangen. 

Abschließend wird die Verwendung formaler Spezifikationen in Hinblick auf sichere und robuste Software betrachtet.


\section{ACSL-Spezifikation für \texttt{equal}}
\label{sec:design-by-contract:acsl-spezifikation}

Das folgende Codebeispiel zeigt einen formalen Funktionskontrakt für die C-Funktion \texttt{equal}. Es wird
spezifiziert, dass zwei Ganzzahl-Arrays genau dann gleich sind, wenn alle Elemente des Arrays identisch sind.

\lstinputlisting[language=C, caption=Formale Spezifikation von \lstinline{equal} mit ACSL]{codes/equal_contract_acsl.c}

Der @-Präfix zu Beginn des Kommentars in Zeile 1 signalisiert dem Verifikationswerkzeug, 
dass der Kommentarblock als Verifikations-Annotation zu interpretieren ist. 

Die Vorbedingungen des Kontrakts sind in Zeile 2 und 3 definiert: \lstinline{\valid_range} ist ein Prädikat, das sicherstellt,
dass die Zeiger \lstinline{a} und \lstinline{b} gültig sind und auf den Speicherbereich \lstinline{a[0..n]} 
(von \lstinline{a[0]} bis \lstinline{a[n-1]}) bzw. \lstinline{b[0..n]} zugegriffen 
werden darf. Das Prädikat verbietet zudem negative Array-Größen.

Die \lstinline{\assigns}-Klausel beschreibt potenzielle Seiteneffekte. Da es sich bei \texttt{equal} um eine nicht mutierende
Funktion handelt, wird kein Speicherinhalt (\lstinline{\nothing}) verändert.

Der Rückgabewert - als \lstinline{\result} in Zeile 7 bezeichnet - ist genau dann wahr, wenn die Ganzzahlen-Arrays 
\lstinline{a[0..n]} und \lstinline{b[0..n]} elementweise gleich sind. Die Formalisierung nutzt folgende
Prädikatenformel zur Beschreibung dieses Sachverhalts:
\[result \equiv \forall(i) (0 \leq i < n \rightarrow a[i] = b[i])\]

\section{Nutzerdefinierte Prädikate in ACSL und Verifast}
\label{sec:design-by-contract:predicates}

Prädikate sind ein grundlegendes Abstraktionsmittel zum Zusammenfassen und Wiederverwenden logischer
Formeln in ACSL und Verifast.

Für die \texttt{equal}-Spezifikation bietet sich die Einführung eines Prädikates \texttt{IsEqual} an,
da es die Eliminierung und spätere Wiederverwendung der prädikatenlogischen Formel erlaubt. Der Kontrakt
wird dadurch einfacher verständlich, weil statt der längeren Formel aus Zeile 6 (in Listing 3.1) der selbst erklärende
Prädikatenname \texttt{IsEqual} steht.

\lstinputlisting[language=C, caption=Formale Spezifikation von \texttt{equal} mit Hilfe des \lstinline{IsEqual} Prädikats]{codes/equal_contract_predicate_acsl.c}

Die Definition dieses nutzerdefinierten Prädikates geschieht in einem eigenem Annotationsblock wie folgt:

\lstinputlisting[language=C, caption=Prädikat \lstinline{IsEqual} formuliert in ACSL]{codes/equal_predicate_acsl.c}

Die Annotationssprache von Verifast besitzt kein integriertes Prädikat zur Definition gültiger Speicherbereiche,
wie es in ACSL mit \lstinline{\valid_range} existiert. Lediglich das Anfordern einer einzelnen ganzen Zahl hinter
einem \lstinline{int*} Zeiger ist mit dem Prädikat \lstinline{integer} möglich.

Zusammen mit rekursiven Prädikaten lassen sich damit in Verifast ebenfalls vollständige Arrays oder sogar komplexere
Datenstrukturen beschreiben. Der nachfolgende Annotationsblock zeigt ein solches rekursives Prädikat.

\lstinputlisting[language=C, caption=Nutzerdefiniertes Prädikat \lstinline{int_array} in Verifast]{codes/int_array_verifast.c}

Das Prädikat ruft sich solange selbst auf bis \lstinline{count <= 0}. Dass jede Speicherstelle des Arrays \lstinline{start}
gültig ist, erfordert das oben erwähnte \lstinline{integer}-Prädikat. Der zweite Parameter dieses Prädikats erlaubt es eine
Aussage über den Speicherinhalt zu treffen. Da dies in diesem Kontext nicht notwendig ist, wird eine anonyme Variable
\lstinline{_} eingesetzt, da die Angabe des Parameters zwingend notwendig ist.

Die einzelnen Aussagen werden mit der Konjunktion \lstinline{&*&} verknüpft, was dafür sorgt, dass die entsprechenden
Speicherbereiche disjunkt sind (siehe dazu auch \ref{sec:theorie:seperation-logic}). In dem Fall wird also bereits
durch die Syntax klar, dass \lstinline{start} und \lstinline{start + 1} nicht überlappen. Der \lstinline{&&} Operator 
existiert jedoch weiterhin für logische Verknüpfungen.

In dieser Form ist das Prädikat nun semantisch äquivalent zum \lstinline{\valid_range} aus ACSL. Die Zeile 2 aus
der \texttt{equal}-Spezifikation kann in Verifast damit nun als \lstinline{int_array(a, n)} ausgedrückt werden.

Wie oben erwähnt besitzt zwar die Annotationssprache von Verifast kein Prädikat \lstinline{int_array}, das Werkzeug
als solches hingegen schon. Häufig benötigte Prädikate und weitere Funktionen werden in Form von Header-Dateien
mitgeliefert und teilweise sogar automatisch eingebunden\footnote{prelude.h wird automatisch eingebunden, weitere 
Header-Dateien können per \\ \lstinline{//@ #include "listex.gh"} eingebunden werden}.


\section{Induktive Listen mit Verifast}
\label{sec:induktive-listen}

Da Verifast keine Quantoren aus der Prädikatenlogik unterstützt, ist es nicht möglich die \texttt{equal}-Funktion
auf die gleiche Weise wie in ACSL (siehe Listing 3.1) zu beschreiben. Geeignet dafür wären die oben eingeführten
rekursiven Prädikate. Ein noch besserer und flexiblerer Ansatz ist hingegen die Verwendung von induktiven Listen.

Für dessen Verwendung sprechen mehrere Gründe: Listen lassen sich in Verifast mit dem \lstinline{==} Operator vergleichen,
was sich für die Formalisierung von \texttt{equal} sehr anbietet. Außerdem bringt Verifast etliche rekursive Prädikate
mit, die aus einem Array eine Liste konstruieren.

\lstinputlisting[language=C, caption=Definition des generischen Listentyps (übernommen aus list.gh)]{codes/inductive_list_verifast.c}

Ein solches Prädikat lautet \lstinline{ints} und ist eine erweiterte Version des oben vorgestellten Prädikats
\lstinline{int_array}. Zusätzlich zum Zeiger und der Größe des Arrays wird dort ein dritter Parameter angegeben, der
den Speicherinhalt als Liste repräsentiert. 

\lstinputlisting[language=C, caption=Rekursives Prädikat \lstinline{ints}]{codes/ints_predicate_verifast.c}

In der Definition von \lstinline{ints} werden nun die Werte über das \lstinline{integer} Prädikat extrahiert und
daraus die Liste mit Hilfe der Konstruktoren \lstinline{nil} und \lstinline{cons} aus Listing 3.5 erzeugt. Unbekannte
Werte bindet der \lstinline{?} Operator mit Hilfe der Musterkennung (engl. pattern matching) an die entsprechenden
Variablen.

Die Anforderung eines gültigen Arrays sowie die Bindung an eine Listenvariable kann nun kombiniert mit diesem Prädikat
geschehen: \lstinline{ints(a, n, ?al)}. Tatsächlich bietet Verifast dafür auch eine Kurzschreibweise an. Mit dem Zeiger-Operator
(engl. points to) lässt sich äquivalent und besser lesbar \lstinline{a[0..n] |-> ?al} formulieren.

Mit einer durch das Prädikat erzeugten Liste lässt es sich sehr flexibel arbeiten, denn Verifast erlaubt 
die Definition sogenannter Fixpunkt-Funktionen\footnote{im Rahmen dieser Arbeit ist das Schreiben eigener
Fixpunkt-Funktionen nicht notwendig, darum wird nicht detaillierter auf deren Implementierung eingegangen} (engl. fixpoint functions), 
mit denen Listen bzw. beliebige induktive Daten iteriert und manipuliert werden können. Grundlegende
Listen-Utensilien bringt Verifast gleich mit: Implementierungen für \lstinline{head}, 
\lstinline{tail}, \lstinline{append} (Hinzufügen von Elementen) oder auch \lstinline{take} 
(Kopie der ersten N Elemente).


\section{Verifast-Spezifikation für \texttt{equal}}
\label{sec:design-by-contract:verifast-variante}

Eine Formalisierung von \texttt{equal} lässt sich nun mit den bekannten Sprachmitteln in Verifast wie folgt
erreichen.

\lstinputlisting[language=C, caption=Formale Spezifikation der Funktion \lstinline{equal} mit Verifast]{codes/equal_contract_verifast.c}

Dieses Beispiel zeigt zwei kleine syntaktische Unterschiede zwischen ACSL und Verifast: Funktionskontrakte
werden in Verifast nach der Signatur geschrieben, in ACSL jedoch davor. Außerdem erzwingt Verifast die
Formulierung der Vor- und Nachbedingungen in jeweils einer einzigen \lstinline{requires} bzw. \lstinline{ensures}-Anweisung.

Der Rückgabewert ist wie beim ACSL-Kontrakt aus Listing 3.1 genau dann wahr, wenn die Arrays elementweise
identisch sind. In Verifast wird die Aussage jedoch nicht direkt mit Hilfe der Zeiger, sondern indirekt durch die
Listen \lstinline{al} und \lstinline{bl} formuliert.

Eine explizite Angabe zu den Seiteneffekten analog zur \lstinline{assigns}-Klausel ist nicht Teil des Kontrakts. 
Dennoch kann man ableiten, dass es sich um einen nicht-mutierenden Algorithmus handelt. Denn anders als in ACSL
werden nicht die Seiteneffekte selbst beschrieben, sondern der Inhalt des Speichers vor und nach der Ausführung.

Damit erklärt sich wieso in der Nachbedingung die Arrays mit ihrem Gültigkeitsbereich nochmals aufgeführt sind.
Zudem werden die in der Vorbedingung gebundenen Listen wiederverwendet, um per \lstinline{a[0..n] |-> al}
sicherzustellen, dass der Speicherinhalt unverändert ist. Der Zugriff auf die Variablen aus der Vorbedingung ist
dabei ohne weitere Angabe eines \lstinline{\old}-Operators wie in ACSL möglich.

Die Verifast-Spezifikation hat tatsächlich die gleiche Semantik, erreicht dies aber wegen der 
unterschiedlichen Sprachmittel auf eine andere andere Art und Weise.

Wichtig zu erwähnen ist an der Stelle, dass die \lstinline{\assigns nothing}-Klausel aus ACSL wie auch Verifast 
das Ändern des Speicherinhalts erlaubt, solange er zum Ende der Funktion hin wieder rekonstruiert wird.
Es wird lediglich geprüft, dass der Inhalt nach dem Aufruf mit dem vor dem Aufruf übereinstimmt. Eine Feinheit, die im 
Kontext der Parallelprogrammierung wichtig ist, wenn die Funktion inmitten der Ausführung unterbrochen wird bzw. parallel 
zu einer anderen ausgeführt wird, die auf gemeinsame Variablen zurückgreift\footnote{Welche Lese/Schreibrechte
eine Funktion hat, kann in Verifast mit den sogenannten Fractional Permission gesteuert werden. Darauf wird in dieser Arbeit
jedoch nicht weiter eingegangen.}.


\section{Unterschiede in der Umsetzung}

In gewissen Grenzen wäre es möglich die Annotationen der Sprachen eins zu eins zu übersetzen\footnote{Mit
Verifast kann man z.B. auch einen eingeschränkten \(\forall\)-Quantor nachbauen, siehe Tutorial\cite[Kap. 17]{jacobs-tutorial}},
damit würden aber die Vorteile der jeweiligen Sprache keine Anwendung finden. Ein \lstinline{IsEqual}-Prädikat wäre z.B.
auch mit Verifast möglich, macht die Spezifikation aber nicht verständlicher, dafür aber die Verifizierung
der Implementierung schwieriger\footnote{Da dann nicht mehr direkt mit induktiven Listen, sondern zusätzlich
mit einem Prädikat und weiteren erforderlichen Lemmatas gearbeitet werden muss (siehe \ref{verifizierung:lemma})}.

Das Beschreiben der Speicherinhalte und Einführen der Variablen  \lstinline{al} und \lstinline{bl} ist außerdem
ohnehin notwendig, um auszudrücken, dass der Speicher nicht verändert und nicht gelöscht wird. Denn Verifast wertet
auch \lstinline{malloc}- und \lstinline{free}-Aufrufe aus, um den Zugriff auf gelöschten Speicher zu verhindern bzw.
Speicherlöcher nicht entstehen zu lassen.

Es liegt also nahe diese Variablen auch weiter zu verwenden - die Sprachmittel von Verifast (wie die Array-Notation in Kombination mit dem
\lstinline{|->} Operator) drängen einen mehr als ACSL dazu induktive Datentypen zu nutzen.

Der Vorteil ist ein höherer Grad der Abstraktion, denn Aussagen über Listen wie z.B.
\lstinline{result < n ? nth(result, al) != nth(result, bl)} haben keine direkte Abhängigkeit mehr zu
dem Eingabeparameter \lstinline{const int a*}. Ein Wechsel der Datenstruktur von Arrays
hin zu verketteten Listen hätte damit nur einen kleinen Einfluss auf die Spezifikation. Es wäre tatsächlich 
ausreichend die Bindung der Arrays in die induktive Liste zu ändern. Statt \lstinline{a[0..n] |-> ?al} würde man also
z.B. ein Prädikat \lstinline{linked_list} verwenden: \lstinline{linked_list(a, n, ?al)}. Der Rest der 
Spezifikation kann unverändert bleiben.

Andersherrum sieht es ähnlich aus - auch in ACSL wäre es möglich induktive Datentypen zu verwenden, doch
ist das an der Stelle unnötig, da die Quantoren der Prädikatenlogik zur Beschreibung genügen. 
Der Umstieg von ACSL auf Verifast oder andersrum erfordert daher ein Umdenken, damit die Verifizierung 
nicht durch einen ineffizenten Einsatz der Sprachmittel unnötig erschwert wird.



\section{Weitere Strukturierungsmöglichkeiten für Funktionskontrakte in ACSL}
\label{sec:design-by-contract:behaviors}

In ACSL gibt es die Möglichkeit mehrere Fälle (engl. behavior) innerhalb einer Spezifikation getrennt voneinander zu
notieren. Das kann die Lesbarkeit erheblich erleichtern, da man für jeden Fall die Vor- und Nachbedingungen
einzeln lesen und verstehen kann.

Die folgende Spezifikation für \texttt{equal} ist eine solche Variante ohne Verwendung des 
\lstinline{IsEqual}-Prädikats:

\lstinputlisting[language=C, caption=Formale Spezifikation für \texttt{equal} mit Behavior]{codes/equal_behavior_acsl.c}

Der Fall \lstinline{all_equal} in Zeile 7 tritt dann ein, wenn beide Ganzzahl-Arrays gleich sind. Das 
Gegenteil \lstinline{some_not_equal} ist in Zeile 11 definiert, die jeweiligen Bedingungen in Form von
prädikatenlogischen Formeln finden sich als \lstinline{assumes}-Anweisungen wieder. Besonders anzumerken ist,
dass die Anweisungen \lstinline{complete behaviors} bzw. \lstinline{disjoint behaviors} dafür sorgen, dass
alle Fälle abgedeckt und gleichzeitig auch disjunkt sind.

In Verifast wäre das nur manuell zu erreichen, allerdings mit wesentlich längeren Ausdrücken. Reicht 
es in ACSL die \lstinline{assumes}-Fälle \lstinline{a, b, c} als \lstinline{behavior} 
aufzulisten und per \lstinline{disjoint behaviors} zu verknüpfen, so müsste in Verifast die folgende
Formel geschrieben werden:
\[(a \land \neg b \land \neg c) \lor (\neg a \land b \land \neg c) \lor (\neg a \land \neg b \land c)\]


\section{Formale Spezifikationen für \texttt{mismatch} in ACSL und Verifast}

Mit dem Wissen über Prädikate und induktive Listen ist es nun möglich eine formale Spezifikation für \lstinline{mismatch} mit Verifast
zu definieren (für das Verstehen der folgenden Erklärungen ist die informelle Spezifikation aus 
\ref{sec:aufgabenstellung} sehr hilfreich):

\lstinputlisting[language=C, caption=Formale Spezifikation für \lstinline{mismatch} mit Verifast]{codes/mismatch_specification_verifast.c}

Die Nachbedingung beinhaltet die zwei möglichen Fälle: Entweder ist mindestens ein Element ungleich
(\lstinline{result < n}) oder alle sind identisch (\lstinline{result == n}). Das ist leider nicht auf den
ersten Blick in der Spezifikation wiederzufinden, denn das separate Definieren disjunkter Fällen wird in Verifast 
nicht unterstützt (siehe \ref{sec:design-by-contract:behaviors}). 

Die Zeile 3 kombiniert daher beide Fälle (\lstinline{result <= n}) und nutzt die Tatsache aus, dass
der Rückgabewert \lstinline{result} stets die Anzahl der gleichen Elemente enthält: Der Vergleich der
\lstinline{take}-Resultate sorgt dann somit dafür, dass entweder alle Elemente oder nur
alle vor dem ersten gefundenem Unterschied gleich sind. 

Die Fallunterscheidung ist erst am Ende der Nachbedingung sichtbar, innerhalb des \lstinline{? :} Operators.
Intuitiv möchte man an der Stelle \((result < n) \rightarrow al[result] \neq  bl[result]\)
schreiben, kann es aber ohne die Implikation in Verifast nicht so ausdrücken.

\begin{figure}[H]
Die ACSL-Umsetzung verwendet die eben eingeführten Behaviors und ist dementsprechend wesentlich länger:
\lstinputlisting[language=C, caption=ACSL-Variante der Spezifikation für \lstinline{mismatch}]{codes/mismatch_specification_acsl.c}
\end{figure}

Die zwei Fälle sind in diesem Kontrakt besser sichtbar, sinnvoll benannt und damit auch verständlicher, 
da die Spezifikation aus kleineren Teilen besteht. Sie ist lesbarer, mit dem Nachteil viel Platz einzunehmen.
Eine Abwägung zwischen Codelänge und Kompaktheit des Codes ist aber generell schwierig und sehr subjektiv.


\section{Kontrakte für robuste und sichere Implementierungen}
\label{sec:design-by-contract:partielle-korrektheit}

\todo{diesen text überarbeiten}
Das Ziel der in \ref{sec:design-by-contract:acsl-spezifikation} vorgestellten Spezifikation war die
möglichst vollständige funktionale Definition, damit kein Raum für Interpretationen frei bleibt. Allerdings ist
das nicht immer gewünscht: Soll die Robustheit der Software sichergestellt werden, so ist das Aufspüren 
von potenziellen Null-Zeiger-Ausnahmen oder Speicherlöchern das Ziel und nicht die funktionale
Korrektheit. Für ersteres reicht eine reduzierte Spezifikation - funktionale Aspekte werden dabei 
weggelassen oder ggf. vereinfacht:

\lstinputlisting[language=C, caption=Spezifikation ]{codes/equal_partial_contract_verifast.c}
 
Diese Spezifikation ist immer noch korrekt in dem Sinne, dass eine Implementierung der Prozedur
weiterhin verifizierbar ist. Es wird aber nur sichergestellt, dass die Zeiger gültig sind und außerdem
auf den Speicherbereich zugegriffen werden darf. Der Rückgabewert und potenzielle Seiteneffekte des 
Algorithmus sind nicht detaillierter formalisiert.

Denkbar ist auch die Verifizierung der gültigen Aufrufreihenfolge (einer gedachten Zustandsmaschine\footnote{dazu
könnte man jeden Zustand mit einem eigenem Prädikat abbilden und diese in den Vorbedingungen erzwingen}),
ohne alle weiteren Nachbedingungen und Ergebnisse zu formalisieren. Somit kann sichergestellt werden,
dass sich die Zustandsmaschine niemals in einem ungültigen Zustand befindet. Ansonsten erforderliche
Laufzeit-Überprüfungen können dann wegfallen.
