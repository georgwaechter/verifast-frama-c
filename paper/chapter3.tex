\chapter{Vergleich der Sprachen für die Funktionskontrakte}
\label{sec:design-by-contract}

Dieses Kapitel vergleicht die Sprachkonstrukte aus ACSL und Verifast für die Beschreibung von Funktionskontrakten.

Nutzerdefinierte Prädikate und induktive Listen werden an Hand des einfachen \texttt{equal}-Algorithmus vorgestellt.
Daraufhin wird eine weitere Strukturierungsmöglichkeit für Kontrakte in ACSL diskutiert und bei der anschließenden
Formalisierung von \texttt{mismatch} verwendet. Die Verifast-Variante wird vorgestellt und auf die Unterschiede
der beiden Umsetzungen eingegangen. 

Abschließend wird die Verwendung formaler Spezifikationen in Hinblick auf sichere und robuste Software betrachtet.


\section{ACSL-Spezifikation für \texttt{equal}}
\label{sec:design-by-contract:acsl-spezifikation}

Das folgende Codebeispiel zeigt einen formalen Funktionskontrakt für die C-Funktion \texttt{equal}. Es wird
spezifiziert, dass zwei Ganzzahl-Arrays genau dann gleich sind, wenn alle Elemente des Arrays identisch sind.

\lstinputlisting[language=C, caption=Formale Spezifikation von \lstinline{equal} mit ACSL]{codes/equal_contract_acsl.c}

Der @-Präfix zu Beginn des Kommentars in Zeile 1 signalisiert dem Verifikationswerkzeug, 
dass der Kommentarblock als Verifikations-Annotation zu interpretieren ist. 

Die Vorbedingungen des Kontrakts sind in Zeile 2 und 3 definiert: \lstinline{\valid_range} ist ein Prädikat, das sicherstellt,
dass die Zeiger \lstinline{a} und \lstinline{b} gültig sind und auf den Speicherbereich \lstinline{a[0..n]} 
(von \lstinline{a[0]} bis \lstinline{a[n-1]}) bzw. \lstinline{b[0..n]} zugegriffen 
werden darf. Das Prädikat verbietet zudem negative Array-Größen.

Die \lstinline{\assigns}-Klausel beschreibt potenzielle Seiteneffekte. Da es sich bei \texttt{equal} um eine nicht mutierende
Funktion handelt, wird kein Speicherinhalt (\lstinline{\nothing}) verändert.

Der Rückgabewert - als \lstinline{\result} in Zeile 7 bezeichnet - ist genau dann wahr, wenn die Ganzzahlen-Arrays 
\lstinline{a[0..n]} und \lstinline{b[0..n]} elementweise gleich sind. Die Formalisierung nutzt folgende
Prädikatenformel zur Beschreibung dieses Sachverhalts:
\[result \equiv \forall(i) (0 \leq i < n \rightarrow a[i] = b[i])\]

\section{Nutzerdefinierte Prädikate in ACSL und Verifast}
\label{sec:design-by-contract:predicates}

Prädikate sind ein grundlegendes Abstraktionsmittel zum Zusammenfassen und Wiederverwenden logischer
Formeln in ACSL und Verifast.

Für die \texttt{equal}-Spezifikation bietet sich die Einführung eines Prädikates \texttt{IsEqual} an,
da es die Eliminierung und spätere Wiederverwendung der prädikatenlogischen Formel erlaubt. Der Kontrakt
wird dadurch einfacher verständlich, weil statt der längeren Formel aus Zeile 6 (in Listing 3.1) der selbst erklärende
Prädikatenname \texttt{IsEqual} steht.

\lstinputlisting[language=C, caption=Formale Spezifikation von \texttt{equal} mit Hilfe des \lstinline{IsEqual} Prädikats]{codes/equal_contract_predicate_acsl.c}

Die Definition dieses nutzerdefinierten Prädikates geschieht in einem eigenem Annotationsblock wie folgt:

\lstinputlisting[language=C, caption=Prädikat \lstinline{IsEqual} formuliert in ACSL]{codes/equal_predicate_acsl.c}

Die Annotationssprache von Verifast besitzt kein integriertes Prädikat zur Definition gültiger Speicherbereiche,
wie es in ACSL mit \lstinline{\valid_range} existiert. Lediglich das Anfordern einer einzelnen ganzen Zahl hinter
einem \lstinline{int*} Zeiger ist mit dem Prädikat \lstinline{integer} möglich.

Zusammen mit rekursiven Prädikaten lassen sich damit in Verifast ebenfalls vollständige Arrays oder sogar komplexere
Datenstrukturen beschreiben. Der nachfolgende Annotationsblock zeigt ein solches rekursives Prädikat.

\lstinputlisting[language=C, caption=Nutzerdefiniertes Prädikat \lstinline{int_array} in Verifast]{codes/int_array_verifast.c}

Das Prädikat ruft sich solange selbst auf bis \lstinline{count <= 0}. Dass jede Speicherstelle des Arrays \lstinline{start}
gültig ist, erfordert das oben erwähnte \lstinline{integer}-Prädikat. Der zweite Parameter dieses Prädikats erlaubt es eine
Aussage über den Speicherinhalt zu treffen. Da dies in diesem Kontext nicht notwendig ist, wird eine anonyme Variable
\lstinline{_} eingesetzt, da die Angabe des Parameters zwingend notwendig ist.

Die einzelnen Aussagen werden mit der Konjunktion \lstinline{&*&} verknüpft\footnote{Der \lstinline{&&} Operator 
existiert zusätzlich für logische Verknüpfungen.}, was dafür sorgt, dass die entsprechenden
Speicherbereiche disjunkt sind (siehe dazu auch \ref{sec:theorie:seperation-logic}). In dem Fall wird also bereits
durch die Syntax klar, dass \lstinline{start} und \lstinline{start + 1} nicht überlappen. Ein solches Prädikat
mit Angaben zu Speicherinhalten wird auch als Heap-Chunk bezeichnet und beschreibt das Recht diesen zu
manipulieren\footnote{Die Lese/Schreibrechte eines Heap-Chunks können in Verifast über einen Koeffizienten
(engl. fractional permissions) gesteuert werden. Darauf wird in dieser Arbeit jedoch nicht weiter eingegangen.}.

In dieser Form ist das Prädikat nun semantisch äquivalent zum \lstinline{\valid_range} aus ACSL. Die Zeile 2 aus
der \texttt{equal}-Spezifikation kann in Verifast damit nun als \lstinline{int_array(a, n)} ausgedrückt werden.

Wie oben erwähnt besitzt zwar die Annotationssprache von Verifast kein Prädikat \lstinline{int_array}, das Werkzeug
als solches hingegen schon. Häufig benötigte Prädikate und weitere Funktionen werden in Form von Header-Dateien
mitgeliefert und teilweise sogar automatisch eingebunden\footnote{prelude.h wird automatisch eingebunden, weitere 
Header-Dateien können per \\ \lstinline{//@ #include "listex.gh"} eingebunden werden}.


\section{Induktive Listen mit Verifast}
\label{sec:induktive-listen}

Da Verifast keine Quantoren aus der Prädikatenlogik unterstützt, ist es nicht möglich die \texttt{equal}-Funktion
auf die gleiche Weise wie in ACSL (siehe Listing 3.1) zu beschreiben. Geeignet dafür wären die oben eingeführten
rekursiven Prädikate. Ein noch besserer und flexiblerer Ansatz ist hingegen die Verwendung von induktiven Listen.

Für dessen Verwendung sprechen mehrere Gründe: Listen lassen sich in Verifast mit dem \lstinline{==} Operator vergleichen,
was sich für die Formalisierung von \texttt{equal} sehr anbietet. Außerdem bringt Verifast etliche rekursive Prädikate
mit, die aus einem Array eine Liste konstruieren.

\lstinputlisting[language=C, caption=Definition des generischen Listentyps (übernommen aus list.gh)]{codes/inductive_list_verifast.c}

Ein solches Prädikat lautet \lstinline{ints} und ist eine erweiterte Version des oben vorgestellten Prädikats
\lstinline{int_array}. Zusätzlich zum Zeiger und der Größe des Arrays wird dort ein dritter Parameter angegeben, der
den Speicherinhalt als Liste repräsentiert. 

\lstinputlisting[language=C, caption=Rekursives Prädikat \lstinline{ints}]{codes/ints_predicate_verifast.c}

In der Definition von \lstinline{ints} werden nun die Werte über das \lstinline{integer} Prädikat extrahiert und
daraus die Liste mit Hilfe der Konstruktoren \lstinline{nil} und \lstinline{cons} aus Listing 3.5 erzeugt. Unbekannte
Werte bindet der \lstinline{?} Operator mit Hilfe der Musterkennung (engl. pattern matching) an die entsprechenden
Variablen.

Die Anforderung eines gültigen Arrays sowie die Bindung an eine Listenvariable kann nun kombiniert mit diesem Prädikat
geschehen: \lstinline{ints(a, n, ?al)}. Tatsächlich bietet Verifast dafür auch eine Kurzschreibweise an. Mit dem Zeiger-Operator
(engl. points to) lässt sich äquivalent und besser lesbar \lstinline{a[0..n] |-> ?al} formulieren.

Mit einer durch das Prädikat erzeugten Liste lässt es sich sehr flexibel arbeiten, denn Verifast erlaubt 
die Definition sogenannter Fixpunkt-Funktionen\footnote{im Rahmen dieser Arbeit ist das Schreiben eigener
Fixpunkt-Funktionen nicht notwendig, darum wird nicht detaillierter auf deren Implementierung eingegangen} (engl. fixpoint functions), 
mit denen Listen bzw. beliebige induktive Daten iteriert und manipuliert werden können. Grundlegende
Listen-Utensilien bringt Verifast gleich mit: Implementierungen für \lstinline{head}, 
\lstinline{tail}, \lstinline{append} (Hinzufügen von Elementen) oder auch \lstinline{take} 
(Kopie der ersten N Elemente).


\section{Verifast-Spezifikation für \texttt{equal}}
\label{sec:design-by-contract:verifast-variante}

Eine Formalisierung von \texttt{equal} lässt sich nun mit den bekannten Sprachmitteln in Verifast wie folgt
erreichen.

\lstinputlisting[language=C, caption=Formale Spezifikation der Funktion \lstinline{equal} mit Verifast]{codes/equal_contract_verifast.c}

Dieses Beispiel zeigt zwei kleine syntaktische Unterschiede zwischen ACSL und Verifast: Funktionskontrakte
werden in Verifast nach der Signatur geschrieben, in ACSL jedoch davor. Außerdem erzwingt Verifast die
Formulierung der Vor- und Nachbedingungen in jeweils einer einzigen \lstinline{requires} bzw. \lstinline{ensures}-Anweisung.

Der Rückgabewert ist wie beim ACSL-Kontrakt aus Listing 3.1 genau dann wahr, wenn die Arrays elementweise
identisch sind. In Verifast wird die Aussage jedoch nicht direkt mit Hilfe der Zeiger, sondern indirekt durch die
Listen \lstinline{al} und \lstinline{bl} formuliert.

Eine explizite Angabe zu den Seiteneffekten analog zur \lstinline{assigns}-Klausel ist nicht Teil des Kontrakts. 
Dennoch kann man ableiten, dass es sich um einen nicht-mutierenden Algorithmus handelt. Denn anders als in ACSL
werden nicht die Seiteneffekte selbst beschrieben, sondern der Inhalt des Speichers vor und nach der Ausführung.
Diese Angabe ist obligatorisch, da der C-Code der Implementierung nur auf Speicher zugreifen darf, der in der
Vorbedingung erwähnt wurde.

Damit erklärt sich weshalb in der Nachbedingung die Arrays mit ihrem Gültigkeitsbereich nochmals aufgeführt sind.
Zudem werden die in der Vorbedingung gebundenen Listen wiederverwendet, um per \lstinline{a[0..n] |-> al}
sicherzustellen, dass der Speicherinhalt unverändert ist. Der Zugriff auf die Variablen aus der Vorbedingung ist
dabei ohne weitere Angabe eines \lstinline{\old}-Operators wie in ACSL möglich.

Die Verifast-Spezifikation hat tatsächlich die gleiche Semantik, erreicht dies aber wegen der 
unterschiedlichen Sprachmittel auf eine andere andere Art und Weise.


\section{Unterschiede in der Umsetzung}

In gewissen Grenzen wäre es möglich die Annotationen der Sprachen eins zu eins zu übersetzen\footnote{Mit
Verifast kann man z.B. auch einen eingeschränkten \(\forall\)-Quantor nachbauen, siehe Tutorial\cite[Kap. 17]{jacobs-tutorial}},
damit würden aber die Vorteile der jeweiligen Sprache keine Anwendung finden. Ein \lstinline{IsEqual}-Prädikat wäre z.B.
auch mit Verifast möglich, macht die Spezifikation aber nicht verständlicher, dafür aber die Verifizierung
der Implementierung schwieriger\footnote{Da dann nicht mehr direkt mit induktiven Listen, sondern zusätzlich
mit einem Prädikat und weiteren erforderlichen Lemmatas gearbeitet werden muss (siehe \ref{verifizierung:lemma})}.

Das Beschreiben der Speicherinhalte und Einführen der Variablen  \lstinline{al} und \lstinline{bl} ist außerdem
ohnehin notwendig, um auszudrücken, dass der Speicher nicht verändert und nicht gelöscht wird. Denn Verifast wertet
auch \lstinline{malloc}- und \lstinline{free}-Aufrufe aus, um den Zugriff auf gelöschten Speicher zu verhindern bzw.
Speicherlöcher nicht entstehen zu lassen.

Es liegt also nahe diese Variablen auch weiter zu verwenden - die Sprachmittel von Verifast (wie die Array-Notation in Kombination mit dem
\lstinline{|->} Operator) drängen einen mehr als ACSL dazu induktive Datentypen zu nutzen.

Der Vorteil ist ein höherer Grad der Abstraktion, denn Aussagen über Listen wie z.B.
\lstinline{result < n ? nth(result, al) != nth(result, bl)} haben keine direkte Abhängigkeit mehr zu
dem Eingabeparameter \lstinline{const int a*}. Ein Wechsel der Datenstruktur von Arrays
hin zu verketteten Listen hätte damit nur einen kleinen Einfluss auf die Spezifikation. Es wäre tatsächlich 
ausreichend die Bindung der Arrays in die induktive Liste zu ändern. Statt \lstinline{a[0..n] |-> ?al} würde man also
z.B. ein Prädikat \lstinline{linked_list} verwenden: \lstinline{linked_list(a, n, ?al)}. Der Rest der 
Spezifikation kann unverändert bleiben.

Andersherrum sieht es ähnlich aus - auch in ACSL wäre es möglich induktive Datentypen zu verwenden, doch
ist das an der Stelle unnötig, da die Quantoren der Prädikatenlogik zur Beschreibung genügen. 
Der Umstieg von ACSL auf Verifast oder andersrum erfordert daher ein Umdenken, damit die Verifizierung 
nicht durch einen ineffizenten Einsatz der Sprachmittel unnötig erschwert wird.



\section{Weitere Strukturierungsmöglichkeiten für Funktionskontrakte in ACSL}
\label{sec:design-by-contract:behaviors}

In ACSL gibt es die Möglichkeit mehrere Fälle (engl. behavior) innerhalb einer Spezifikation getrennt voneinander zu
notieren. Das kann die Lesbarkeit erheblich erleichtern, da man für jeden Fall die Vor- und Nachbedingungen
einzeln lesen und verstehen kann.

Die folgende Spezifikation für \texttt{equal} ist eine solche Variante ohne Verwendung des 
\lstinline{IsEqual}-Prädikats:

\lstinputlisting[language=C, caption=Formale Spezifikation für \texttt{equal} mit Behavior]{codes/equal_behavior_acsl.c}

Der Fall \lstinline{all_equal} in Zeile 7 tritt dann ein, wenn beide Ganzzahl-Arrays gleich sind. Das 
Gegenteil \lstinline{some_not_equal} ist in Zeile 11 definiert, die jeweiligen Bedingungen in Form von
prädikatenlogischen Formeln finden sich als \lstinline{assumes}-Anweisungen wieder. Besonders anzumerken ist,
dass die Anweisungen \lstinline{complete behaviors} bzw. \lstinline{disjoint behaviors} dafür sorgen, dass
alle Fälle abgedeckt und gleichzeitig auch disjunkt sind.

In Verifast wäre das nur manuell zu erreichen, allerdings mit wesentlich längeren Ausdrücken. Reicht 
es in ACSL die \lstinline{assumes}-Fälle \lstinline{a, b, c} als \lstinline{behavior} 
aufzulisten und per \lstinline{disjoint behaviors} zu verknüpfen, so müsste in Verifast die folgende
Formel geschrieben werden:
\[(a \land \neg b \land \neg c) \lor (\neg a \land b \land \neg c) \lor (\neg a \land \neg b \land c)\]


\section{Formale Spezifikationen für \texttt{mismatch} in ACSL und Verifast}

Mit dem Wissen über Prädikate und induktive Listen ist es nun möglich eine formale Spezifikation für \lstinline{mismatch} mit Verifast
zu definieren (für das Verstehen der folgenden Erklärungen ist die informelle Spezifikation aus 
\ref{sec:aufgabenstellung} sehr hilfreich):

\lstinputlisting[language=C, caption=Formale Spezifikation für \lstinline{mismatch} mit Verifast]{codes/mismatch_specification_verifast.c}

Die Nachbedingung beinhaltet die zwei möglichen Fälle: Entweder ist mindestens ein Element ungleich
(\lstinline{result < n}) oder alle sind identisch (\lstinline{result == n}). Das ist leider nicht auf den
ersten Blick in der Spezifikation wiederzufinden, denn das separate Definieren disjunkter Fällen wird in Verifast 
nicht unterstützt (siehe \ref{sec:design-by-contract:behaviors}). 

Die Zeile 3 kombiniert daher beide Fälle (\lstinline{result <= n}) und nutzt die Tatsache aus, dass
der Rückgabewert \lstinline{result} stets die Anzahl der gleichen Elemente enthält: Der Vergleich der
\lstinline{take}-Resultate sorgt dann somit dafür, dass entweder alle Elemente oder nur
alle vor dem ersten gefundenem Unterschied gleich sind. 

Die Fallunterscheidung ist erst am Ende der Nachbedingung sichtbar, innerhalb des \lstinline{? :} Operators.
Intuitiv möchte man an der Stelle \((result < n) \rightarrow al[result] \neq  bl[result]\)
schreiben, kann es aber ohne die Implikation in Verifast nicht so ausdrücken.

\begin{figure}[H]
Die ACSL-Umsetzung verwendet die eben eingeführten Behaviors und ist dementsprechend wesentlich länger:
\lstinputlisting[language=C, caption=ACSL-Variante der Spezifikation für \lstinline{mismatch}]{codes/mismatch_specification_acsl.c}
\end{figure}

Die zwei Fälle sind in diesem Kontrakt besser sichtbar, sinnvoll benannt und damit auch verständlicher, 
da die Spezifikation aus kleineren Teilen besteht. Sie ist lesbarer, mit dem Nachteil viel Platz einzunehmen.
Eine Abwägung zwischen Codelänge und Kompaktheit des Codes ist aber generell schwierig und sehr subjektiv.


\section{Kontrakte für robuste und sichere Implementierungen}
\label{sec:design-by-contract:partielle-korrektheit}

Die Funktionskontrakte in diesem Kapitel sind alle mit Hinblick auf eine vollständige Verhaltensbeschreibung
enstanden. Dennoch können sie kaum als vollständig bezeichnet werden, da die Vollständigkeit eines Kontraktes
nur im Zusammenhang mit dem Verifikationsziel bewertet werden kann. Beispielsweise könnte für zeitkritische
Systeme neben der Beschreibung des Verhaltens auch die Laufzeitkomplexität von Interesse sein.

Für den Nachweis der Robustheit ist es wichtig die Abwesenheit fataler Laufzeitfehler zu garantieren,
damit unerwartete Eingaben die Software nicht zum Absturz bringen können. Mit den Verifikationswerkzeugen lassen 
sich folgende Fehler erkennen und deren Abwesenheit verifizieren:
\begin{enumerate}
\item Dereferenzierung von Nullzeigern
\item Zugriff auf Speicherinhalte außerhalb der Arraygrenzen
\item Fehlerhafte Speicherverwaltung
\item Arithmetische Überläufe
\end{enumerate}

VeriFast und Frama-C prüfen bei der Derefenzierung einer Zeigervariablen stets, dass diese gültig ist (das heißt
nicht \texttt{null}) und sich im zuvor definiertem Gültigkeitsbereich befindet. Listing 3.11 zeigt einen Funktionskontrakt, 
der bei erfolgreicher Verifizierung der Implementierung die Probleme eins und zwei ausschließt.

\lstinputlisting[language=C, caption=Spezifikation für \texttt{equal} mit Fokus auf Robustheit]{codes/equal_robust_contract_acsl.c}

Das Verhindern arithmetischer Überläufe kann nicht direkt im Kontrakt vereinbart werden. Im Werkzeug VeriFast
ist es eine Option, die für die Verifizierung an - oder ausgeschaltet werden kann. In Frama-C ... \todo{testen}

Den Umgang mit malloc bzw. free versteht nur das Verifikationswerkzeug VeriFast. Mit dessen Hilfe ist es möglich
nie freigegebenen Speicher oder auch das doppelte Löschen eines Speicherbereichs zu erkennen. Die Grundlage dafür
sind die bereits in \ref{} eingeführten Heap Chunks, die den Zugriff auf disjunkte Speicherbereiche definieren. 
Anders als der Name es implizieren lässt, sind damit aber nicht nur Speicherinhalt im tatsächlichen Freispeicher
(engl. heap) gemeint, sondern auch solche auf dem Stapelspeicher (engl. stack). Tatsächlich legt VeriFast für
per malloc allokierte Bereiche einen zusätzlichen zweiten Chunk an, damit eine Unterscheidung zwischen Stack und
Heap möglich ist. Somit kann z.B. auch ein fehlerhafter free-Aufruf erkannt werden, der Teile des Stacks löschen soll.

malloc block ints zeigen

keine funktion nur die ints chunks nehmen, aber die malloc block ints nicht mit nehmen in der precondition? z.B. sinnvoll

\todo{leaken zeigen}

\todo{testen ob frama-c auch problem meldet bei zugriff auf a[n]}

