
\chapter{Grundkonzepte}

\section{Design by Contract}
\label{sec:design-by-contract}

Bei der formalen Verifikation geht es darum sicherzustellen, dass ein entsprechendes Stück Software
funktional korrekt ist. Das wird erreicht, in dem man die Bausteine der Sprache - in C sind es zum Beispiel die Methoden 
oder Strukturen -
Stück für Stück formalisiert und verifiziert. Die Signatur einer Methode stellt bereits einen einfachen Vertrag zwischen
Aufrufenden und Aufrufer dar - Eingabeparameteranzahl und Typ sind festgelegt, genauso wie der Rückgabewert.
Um auch die funktionalen Aspekte der Methode zu beschreiben, erweitern wir diesen Vereinbarung um sogenannte Vor- und Nachbedingungen.
Diese beschreiben das Resultat der Methode sowie notwendige Annahmen, die vor dem Aufrufen der Methode gegeben sein müssen. 

Somit entstehen exakte vollständig formalisierte Bausteine, die keinen Raum für Ungenauigkeiten oder Interpretationen zulassen.
Diese Herangehensweise nennt sich Design by Contract und ist die Grundidee \todo{aller?} vieler Verifikationswerkzeuge.


pre und post condition, abstrakte datentypen (siehe 2.)


in frama-c zusätzlich noch: globale invarianten
  
  
pre condition beschreibt annahmen für die ausführung
  
  
post condition beschreibt effekt der methode 
  (rückgabewert und ggf. seiteneffekte)

  
partielle korrektheit zeigen (keine funktionale), gültige zeiger und kein speicherleck
(prädikate, rekursives prädikat für speicherbereich)
  
funktionale korrektzeit spezifizieren: einfaches equal beispiel 
(vorher prädikatenlogik-variante ggf)
(acls-variante zeigen)


assertions in seperation logic oder first order logic


\section{Abstrakte Datentypen}

induktive datentypen an hand von liste zeigen


keine entsprechung in frama-c (beschränktheit prädikatenlogik erster stufe - bäume?)


kombination mit rekursiven prädikaten erläutern


mismatch-spezifikation zeigen


\section{Behaviors}


behaviors drücken pre- und postconditions in frama-c lesbarer aus


keine alternative dafür in verifast, dafür kann manches kürzer ausgedrückt werden mit hilfe von induktiven datentypen


\section{Verifikation von Implementierungen}

Rekursive Implementierung von mismatch
in verifast

ghost commands
(prädikate öffnen)
(präzise prädikate)


produce/consume assertions
toolunterstützung verifast zeigen und erklären


in acsl zeigen
unterschied erklären


schleifeninvarianten


