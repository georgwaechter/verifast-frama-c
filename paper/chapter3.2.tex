\section{Induktive Listen mit Verifast}
\label{sec:induktive-listen}

Schaut man sich die Verifast-Spezifikation von \lstinline{equal} genauer an, fällt auf, dass es 
möglich ist die Inhalte der zwei Speicherbereiche mit \lstinline{==} (siehe Zeile 3) zu vergleichen. 
Dazu hier nochmal der entsprechende Code-Auszug:

\lstinputlisting[language=C]{codes/equal_contract_verifast.c}

Der \lstinline{==} Operator nach der \lstinline{result}-Variable ist ein einfacher boolescher Vergleich,
der zweite \lstinline{==} Operator hingegen vergleicht die beiden Variablen \lstinline{al} und \lstinline{bl}.

Der Vergleich ist möglich, da es sich um Listen vom Typ \lstinline{list<int>} handelt. Dies ist ein
von Verifast mitgelieferter (generischer) induktiver Datentyp, ganz ähnlich zu den Listen in funktionalen 
Sprachen wie Haskell. Damit ist klar, dass die Array-Notation \lstinline{a[0..n] |-> ?al} dafür sorgt, 
dass der Speicherinhalt bei der Mustererkennung als induktive Liste gebunden wird.

Induktive Typen können wie folgt definiert werden - hier die \lstinline{list}-Definition von Verifast:

\lstinputlisting[language=C]{codes/inductive_list_verifast.c}

Um zu verstehen wie diese eingesetzt werden, wird das offizielle Verifast \lstinline{ints}-Prädikat genauer
erläutert. Dieses wurde oben bereits verwendet, denn es ist tatsächlich nur eine andere Schreibweise für die 
lesbarere Array-Notation. Das Binden der Inhalte aus dem Array \lstinline{a} ist darum auch alternativ via 
\lstinline{ints(a, n, ?al)} möglich.

Nachfolgend ist das rekursive \lstinline{ints}-Prädikat abgebildet. Gut zu erkennen ist dabei
wie die \lstinline{intlist} Stück für Stück rekursiv mit Hilfe der Konstruktoren
\lstinline{cons} bzw. \lstinline{nil} erzeugt wird.

\lstinputlisting[language=C]{codes/ints_predicate_verifast.c}

Mit diesen Listen kann man nun flexibel arbeiten, denn Verifast erlaubt die Definition sogenannter
\lstinline{fixpoint}-Funktionen, mit denen die Listen manipuliert werden. Die grundlegendsten
Listen-Utensilien bringt Verifast aber gleich mit, z.B. Implementierungen für \lstinline{head}, 
\lstinline{tail}, \lstinline{append} (Hinzufügen von Elementen) oder auch \lstinline{take} 
(Kopie der ersten N Elemente).



\section{Mismatch-Spezifikation}

Mit diesem Wissen ist es nun möglich eine formale Spezifikation für \lstinline{mismatch} mit Verifast
zu definieren (für das Verstehen der folgenden Erklärungen ist die informelle Spezifikation aus 
\ref{sec:aufgabenstellung} sehr hilfreich):

\lstinputlisting[language=C]{codes/mismatch_specification_verifast.c}

\todo{noch genauer erklären?}
Es gibt in der Nachbedingung zwei mögliche Fälle: Entweder sind die Arrays ungleich
(\lstinline{result < n}) oder sie sind gleich (\lstinline{result == n}). Das ist leider nicht direkt
in der Spezifikation wiederzufinden, denn das separate Definieren disjunkter Fällen wird in Verifast 
nicht unterstützt (siehe \ref{sec:design-by-contract:behaviors}). Die Zeile 3 kombiniert daher beide Fälle 
in einem, was die Lesbarkeit etwas beeinträchtigt - das Resultat ist dafür sehr kompakt.

Da Verifast keine Prädikatenlogik kennt, gibt es weder Quantoren noch Implikation. Am Ende der
Nachbedingung beispielsweise möchte man intuitiv \((result < n) \rightarrow al[result] \neq  bl[result]\)
schreiben, kann es aber nur wie folgt ausdrücken: 
\lstinline{result < n ? nth(result, al) != nth(result, bl) : true}.

Die ACSL-Umsetzung hingegen ist wesentlich länger und verwendet Behaviors:

\lstinputlisting[language=C]{codes/mismatch_specification_acsl.c}

Die zwei Fälle sind in dieser Variante besser sichtbar und damit auch verständlicher, da die Spezifikation
aus kleineren Teilen besteht. Sie ist somit lesbarer, mit dem Nachteil viel Platz einzunehmen.
Die Abwägung zwischen Codelänge und Kompaktheit des Codes ist aber generell schwierig und subjektiv.

Des Weiteren fällt auf, dass die ACSL-Spezifikation direkt mit den Variablen \lstinline{a} und
\lstinline{b} arbeitet, wohingegen die Verifast-Variante die funktionalen Aspekte ausschließlich
mit Hilfe der induktiven Listen \lstinline{al} und \lstinline{bl} beschreibt. 



\section{Unterschiede in der Umsetzung}

In gewissen Grenzen wäre es zwar auch möglich die Annotationen eins zu eins zu übersetzen, aber damit
würden die Vorteile der jeweiligen Sprache verloren gehen. Ein \lstinline{IsEqual}-Prädikat wäre z.B.
auch mit Verifast möglich, macht die Spezifikation aber nicht verständlicher, sondern nur die Verifizierung
der Implementierung schwieriger. \todo{Referenz auf stelle in 3.3}

Das Angeben der Speicherinhalte und Einführen der Variablen  \lstinline{al} und \lstinline{bl} ist außerdem
ohnehin notwendig, um auszudrücken, dass der Speicher nicht verändert und nicht von der Funktion selber
gelöscht wird. Denn Verifast wertet auch \lstinline{malloc}- und \lstinline{free}-Aufrufe aus, um 
den Zugriff auf gelöschten Speicher zu verhindern als auch das doppelte Entfernen von diesem.

Es liegt also nahe diese Varaiblen auch weiter zu verwenden - die Sprachmittel von Verifast (wie die Array-Notation in Kombination mit dem
\lstinline{|->} Operator) drängen einen mehr als ACSL dazu induktive Datentypen zu nutzen.

Der Vorteil ist ein höherer Grad der Abstraktion, denn Aussagen über Listen wie z.B.
\lstinline{result < n ? nth(result, al) != nth(result, bl)} haben keine Abhängigkeit mehr zu
dem Eingabeparameter \lstinline{const int a*}. Damit hätte ein Wechsel der Datenstruktur von Arrays
hin zu verketteten Listen nur einen kleinen Einfluss auf die Spezifikation. Es wäre tatsächlich ausreichend
die Bindung der Arrays in die induktive Liste zu ändern. Statt \lstinline{a[0..n] |-> ?al} würde man also
z.B. ein Prädikat \lstinline{linked_list} verwenden: \lstinline{linked_list(a, n, ?al)}. Der Rest der 
Spezifikation kann unverändert bleiben.

\todo{recursive logic definitions in acsl zeigen?}
Andersherrum sieht es ähnlich aus - auch in ACSL wäre es möglich induktive Datentypen zu verwenden, doch
ist das an der Stelle unnötig, da die Quantoren der Prädikatenlogik zur Beschreibung genügen. 
Der Umstieg von ACSL auf Verifast oder andersrum erfordert daher ein Umdenken, damit die Verifizierung 
nicht durch einen ineffizenten Einsatz der Sprachmittel unnötig erschwert wird.

\todo{erwähnen, dass mustererkennung ein teilweise ersatz für existenz-quantor ist}

