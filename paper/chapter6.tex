\chapter{Fazit}

Abschließend lässt sich sagen, dass beide Werkzeuge sehr gut geeignet sind, um die funktionalen Eigenschaften von
Algorithmen nachzuweisen. Für die einfachen Beispiele in dieser Arbeit ist Frama-C jedoch etwas passender, da die
entsprechenden Kontrakte einfacher zu schreiben sowie zu lesen sind.

VeriFast spielt seine Stärken bei komplizierten Datenstrukturen aus und dann wenn es neben den funktionalen Eigenschaften
auch oder ausschließlich um die Robustheit des Codes geht. Aktuell ist von den beiden Werkzeugen nur VeriFast in der Lage
eine korrekte Speicherverwaltung nachzuweisen.

Die beiden Werkzeuge verfolgen einen unterschiedlichen Ansatz. VeriFast hat eine intuitive Oberfläche, welche die Verifizierung
erleichtert - erwartet aber mehr Annotationen im Quellcode. Das liegt daran, dass der Beweiser bei der Arbeit mit Listen
nicht so mächtig ist wie die Frama-C-Beweiser beim Schlussfolgern im Zusammenspiel mit Quantoren aus der Prädikatenlogik.
Die mit VeriFast geschriebenen Kontrakte ähneln wegen der Nutzung von Listen und den dazugehörigen Fixpunktfunktionen
oft Programmen aus einer funktionalen Sprache wie Haskell. Personen mit einem solchen Hintergrund finden darum einen leichten Zugang zu
VeriFast. Wer aber bereits die Prädikatenlogik kennt oder auch interaktive Beweiser wie Coq, wird sich mit
dem WP-Plugin von Frama-C besser zurecht finden.


\begin{thebibliography}{}
\bibitem[jac12]{jacobs-tutorial} Bart Jacobs, Jan Smans, Frank Piessens: The VeriFast Program Verifier: A Tutorial, Dezember 2012
\bibitem[jac08]{jacobs-2008} Bart Jacobs, Frank Piessens: The Verifast Program Verifier, 2008
\bibitem[jac10]{jacobs-2010} Bart Jacobs, Jans Smans, Frank Piessens: Verifast: Imperative Programs as Proofs, 2010
\bibitem[jac10-1]{jacobs-2010-1} Bart Jacobs, Jan Smans, Frank Piessens: A Quick Tour of the VeriFast Program Verifier
\bibitem[rey02]{reynolds-2002} John C. Reynolds: Seperation Logic: A logic for shared mutable data structures, 2002
\bibitem[phi12]{casestudy} Pieter Philippaerts et al: Software Verification with VeriFast: Industrial Case Studies, 2012
\bibitem[hoare69]{hoare} C.A.R Hore: An axiomatic basis for computer programming, 1969
\bibitem[turing36]{turing} Alan Turing: On computable numbers, with an application to the Entscheidungsproblem, 1936
\bibitem[floyd67]{floyd} R. W. Floyd: Assigning meanings to programs, 1967
\bibitem[vafeiadis11]{concurrent} Viktor Vafeiadis: Concurrent seperation logic and operational semantics, 2011
\end{thebibliography}