\chapter{Fazit}

verifast fühlt sich sehr funktional an?

Doku, Lernkurve, 

geschwindigkeit der tools - geschmackssache ob man eher mehr annotationen mag oder geschwindigkeit, beides geht nicht


kleinere unterschiede in der unterstützung der c-sprach-features
	verifast unterstützt gotos, acsl kann das nicht
	verifast unterstützt keine mehrdimensionalen arrays
	verifast unterstützt kein long, float?
	
dokumentation unterschiedlich?
	
beide werkzeuge eignen sich auch für die verifizierung größerer software, da die verifizierung modular stattfindet

industrieeinsatz, siehe case study

Die Definition der möglichen Seiteneffekte ist in den Sprachen unterschiedlich gelöst. In ACSL
ist an Hand der \lstinline{assigns \nothing} Klausel sofort ersichtlich, dass keine Speichermanipulation
erfolgt. Dieser Aspekt ist in Verifast hingegen nicht so schnell zu erfassen.

\begin{thebibliography}{}
\bibitem[jac12]{jacobs-tutorial} Bart Jacobs, Jan Smans, Frank Piessens: The VeriFast Program Verifier: A Tutorial, Dezember 2012
\bibitem[jac08]{jacobs-2008} Bart Jacobs, Frank Piessens: The Verifast Program Verifier, 2008
\bibitem[jac10]{jacobs-2010} Bart Jacobs, Jans Smans, Frank Piessens: Verifast: Imperative Programs as Proofs, 2010
\bibitem[jac10-1]{jacobs-2010-1} Bart Jacobs, Jan Smans, Frank Piessens: A Quick Tour of the VeriFast Program Verifier
\bibitem[rey02]{reynolds-2002} John C. Reynolds: Seperation Logic: A logic for shared mutable data structures, 2002
\bibitem[phi12]{casestudy} Pieter Philippaerts et al: Software Verification with VeriFast: Industrial Case Studies, 2012
\bibitem[hoare69]{hoare} C.A.R Hore: An axiomatic basis for computer programming, 1969
\bibitem[turing36]{turing} Alan Turing: On computable numbers, with an application to the Entscheidungsproblem, 1936
\bibitem[floyd67]{floyd} R. W. Floyd: Assigning meanings to programs, 1967
\end{thebibliography}